'use strict';

<<<<<<< HEAD
Object.defineProperty(exports, "__esModule", {
=======
Object.defineProperty(exports, '__esModule', {
>>>>>>> master
  value: true
});
exports.default = queueRunner;

var _p_cancelable = require('./p_cancelable');

var _p_cancelable2 = _interopRequireDefault(_p_cancelable);

var _p_timeout = require('./p_timeout');

var _p_timeout2 = _interopRequireDefault(_p_timeout);

<<<<<<< HEAD
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
=======
function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {default: obj};
}
>>>>>>> master

/**
 * Copyright (c) 2014-present, Facebook, Inc. All rights reserved.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
<<<<<<< HEAD
 * 
=======
 *
>>>>>>> master
 */

// Try getting the real promise object from the context, if available. Someone
const Promise = global[Symbol.for('jest-native-promise')] || global.Promise;

function queueRunner(options) {
  const token = new _p_cancelable2.default((onCancel, resolve) => {
    onCancel(resolve);
  });

<<<<<<< HEAD
  const mapper = (_ref) => {
    let fn = _ref.fn,
        timeout = _ref.timeout;

    let promise = new Promise(resolve => {
      const next = function (err) {
=======
  const mapper = _ref => {
    let fn = _ref.fn,
      timeout = _ref.timeout;
    var _ref$initError = _ref.initError;
    let initError = _ref$initError === undefined ? new Error() : _ref$initError;

    let promise = new Promise(resolve => {
      const next = function(err) {
>>>>>>> master
        if (err) {
          options.fail.apply(null, arguments);
        }
        resolve();
      };

<<<<<<< HEAD
      next.fail = function () {
=======
      next.fail = function() {
>>>>>>> master
        options.fail.apply(null, arguments);
        resolve();
      };
      try {
        fn.call(options.userContext, next);
      } catch (e) {
        options.onException(e);
        resolve();
      }
    });

    promise = Promise.race([promise, token]);

    if (!timeout) {
      return promise;
    }

    const timeoutMs = timeout();

<<<<<<< HEAD
    return (0, _p_timeout2.default)(promise, timeoutMs, options.clearTimeout, options.setTimeout, () => {
      const error = new Error('Timeout - Async callback was not invoked within the ' + timeoutMs + 'ms timeout specified by jest.setTimeout.');
      options.onException(error);
    });
  };

  const result = options.queueableFns.reduce((promise, fn) => promise.then(() => mapper(fn)), Promise.resolve());
=======
    return (0, _p_timeout2.default)(
      promise,
      timeoutMs,
      options.clearTimeout,
      options.setTimeout,
      () => {
        initError.message =
          'Timeout - Async callback was not invoked within the ' +
          timeoutMs +
          'ms timeout specified by jest.setTimeout.';
        options.onException(initError);
      }
    );
  };

  const result = options.queueableFns.reduce(
    (promise, fn) => promise.then(() => mapper(fn)),
    Promise.resolve()
  );
>>>>>>> master

  return {
    cancel: token.cancel.bind(token),
    catch: result.catch.bind(result),
    then: result.then.bind(result)
  };
<<<<<<< HEAD
}
=======
}
>>>>>>> master
